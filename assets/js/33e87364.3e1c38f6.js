"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[9438],{34857:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"advanced/window-handles","title":"Window Handles","description":"Overview","source":"@site/xpf/advanced/window-handles.md","sourceDirName":"advanced","slug":"/advanced/window-handles","permalink":"/xpf/advanced/window-handles","draft":false,"unlisted":false,"editUrl":"https://github.com/AvaloniaUI/avalonia-docs/tree/main/xpf/advanced/window-handles.md","tags":[],"version":"current","frontMatter":{"id":"window-handles","title":"Window Handles"},"sidebar":"documentationSidebar","previous":{"title":"Key Mapping","permalink":"/xpf/advanced/key-mapping"},"next":{"title":"Troubleshooting","permalink":"/xpf/troubleshooting"}}');var i=a(74848),d=a(28453);const o={id:"window-handles",title:"Window Handles"},r=void 0,l={},s=[{value:"Overview",id:"overview",level:2},{value:"Getting a Native Window Handle",id:"getting-a-native-window-handle",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["XPF uses a system where the handles returned from various WPF API calls are ",(0,i.jsx)(n.em,{children:"virtual handles"}),". In this way, XPF can intercept API calls using these handles and automatically translate them into the appropriate cross-platform API. This has the effect that many WPF APIs such as ",(0,i.jsx)(n.code,{children:"WindowInteropHelper.Handle"})," return these virtualized window handles, as well as ",(0,i.jsx)(n.a,{href:"/xpf/third-party-libraries",children:"emulated win32 APIs"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"getting-a-native-window-handle",children:"Getting a Native Window Handle"}),"\n",(0,i.jsxs)(n.p,{children:["The native handle for a window can be retrieved from the ",(0,i.jsxs)(n.a,{href:"/xpf/advanced/avalonia-interop#getting-the-avalonia-window",children:["underlying Avalonia ",(0,i.jsx)(n.code,{children:"Window"})]})," using the following code."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"if (XpfWpfAbstraction.GetAvaloniaWindowForWindow(xpfWindow) is { } avaloniaWindow &&\n    avaloniaWindow.TryGetPlatformHandle()?.Handle is { } nativeHandle)\n{\n    // You now have the native handle for the XPF window as an IntPtr.\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The type of the handle retrieved in this manner will be different depending on the OS platform and cannot be passed to the win32 API emulation layer. For example, on Windows it will be a ",(0,i.jsx)(n.code,{children:"HWND"})," but on macOS it will be an ",(0,i.jsx)(n.code,{children:"NSWindow"})," pointer. The type of the handle can be retrieved by using the ",(0,i.jsx)(n.code,{children:"IPlatformHandle.HandleDescriptor"})," property."]})})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var t=a(96540);const i={},d=t.createContext(i);function o(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);