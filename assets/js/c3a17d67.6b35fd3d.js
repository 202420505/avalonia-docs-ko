"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[9420],{6302:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"guides/styles-and-resources/resources","title":"How To Use Resources","description":"You will often need to standardise graphical fundamentals such as (but not limited to) brushes and colors in your applications. You can define these as resources at various levels in your Avalonia UI application, as well as in files that can be included as required.","source":"@site/docs/guides/styles-and-resources/resources.md","sourceDirName":"guides/styles-and-resources","slug":"/guides/styles-and-resources/resources","permalink":"/avalonia-docs-ko/docs/guides/styles-and-resources/resources","draft":false,"unlisted":false,"editUrl":"https://github.com/202420505/avalonia-docs-ko/tree/main/docs/guides/styles-and-resources/resources.md","tags":[],"version":"current","lastUpdatedBy":"202420505","lastUpdatedAt":1755602100000,"frontMatter":{"id":"resources","title":"How To Use Resources"},"sidebar":"documentationSidebar","previous":{"title":"How to Use Included Styles","permalink":"/avalonia-docs-ko/docs/guides/styles-and-resources/how-to-use-included-styles"},"next":{"title":"How To Use Theme Variants","permalink":"/avalonia-docs-ko/docs/guides/styles-and-resources/how-to-use-theme-variants"}}');var o=n(74848),i=n(28453);const t={id:"resources",title:"How To Use Resources"},c="\ud83d\udc49 How To Use Resources",l={},a=[{value:"Declaring Resources",id:"declaring-resources",level:2},{value:"Resource Dictionary Files",id:"resource-dictionary-files",level:2},{value:"Using Resources",id:"using-resources",level:2},{value:"Static Resource",id:"static-resource",level:3},{value:"Resource Priority",id:"resource-priority",level:2},{value:"Include and Merge Resources",id:"include-and-merge-resources",level:2},{value:"Merged Resources Priority",id:"merged-resources-priority",level:2},{value:"Consuming Resources from code",id:"consuming-resources-from-code",level:2}];function d(e){const r={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"-how-to-use-resources",children:"\ud83d\udc49 How To Use Resources"})}),"\n",(0,o.jsxs)(r.p,{children:["You will often need to standardise graphical fundamentals such as (but not limited to) brushes and colors in your applications. You can define these as resources at various levels in your ",(0,o.jsx)(r.em,{children:"Avalonia UI"})," application, as well as in files that can be included as required."]}),"\n",(0,o.jsx)(r.p,{children:"Resources are always defined inside a resource dictionary. This means that each resource has a key attribute."}),"\n",(0,o.jsx)(r.p,{children:"The level of a resource dictionary defines the scope of the resources in it: resources are available in the file where they are defined, and below. So you can tailor the scope of resources by choosing where to locate a resource dictionary."}),"\n",(0,o.jsx)(r.h2,{id:"declaring-resources",children:"Declaring Resources"}),"\n",(0,o.jsxs)(r.p,{children:["For example, you may want brush colors to be standardized across the whole application. In this case you can declare a resource dictionary in the application XAML ",(0,o.jsx)(r.strong,{children:"App.axaml"})," file, like this"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",metastring:'title="App.axaml"',children:'<Application xmlns="https://github.com/avaloniaui"\n             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n             x:Class="MyApp.App">\n    // highlight-start\n  <Application.Resources>\n    <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush>\n  </Application.Resources>\n    // highlight-end\n</Application>\n'})}),"\n",(0,o.jsx)(r.p,{children:"Alternatively, you may want a set of resources to apply only to a specific window or user control. In this case you will define a resource dictionary in the window or user control file. For example:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",metastring:'title="MyUserControl.axaml"',children:'<UserControl xmlns="https://github.com/avaloniaui"\n             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n             x:Class="MyApp.MyUserControl">\n    // highlight-start\n  <UserControl.Resources>\n    <SolidColorBrush x:Key="Warning">LightYellow</SolidColorBrush>\n  </UserControl.Resources>\n    // highlight-end\n</UserControl>\n'})}),"\n",(0,o.jsx)(r.p,{children:"In fact you can define resources at control level if required:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",metastring:'title="MainWindow.axaml"',children:'<Window xmlns="https://github.com/avaloniaui"\n             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n             x:Class="MyApp.MainWindow">\n  <StackPanel>\n    // highlight-start\n    <StackPanel.Resources>\n      <SolidColorBrush x:Key="Warning">PaleGoldenRod</SolidColorBrush>\n    </StackPanel.Resources>\n    // highlight-end\n  </StackPanel>\n</Window>\n'})}),"\n",(0,o.jsx)(r.p,{children:"You can also declare resources to be specific to a style."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",metastring:'title="MyStyle.axaml"',children:'<Style Selector="TextBlock.warning">\n  <Style.Resources>\n    <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush>\n  </Style.Resources>\n  <Setter ... />\n</Style>\n'})}),"\n",(0,o.jsx)(r.admonition,{type:"note",children:(0,o.jsx)(r.p,{children:'Keep in mind, this resource is not visible outside of the this specific style block, meaning it won\'t make every TextBlock with a "warning" class aware of this resource outside of the Style block.'})}),"\n",(0,o.jsxs)(r.p,{children:["It is also possible to define resources for specific theme variants: Dark, Light or custom. From the example below, ",(0,o.jsx)(r.code,{children:"BackgroundBrush"})," and ",(0,o.jsx)(r.code,{children:"ForegroundBrush"})," will have different values depending on the current theme variant set by the system or application. For more information about theme variants please read ",(0,o.jsx)(r.a,{href:"how-to-use-theme-variants",children:"Theme Variants"})," page."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:"<ResourceDictionary>\n    <ResourceDictionary.ThemeDictionaries>\n        <ResourceDictionary x:Key='Light'>\n            <SolidColorBrush x:Key='BackgroundBrush'>White</SolidColorBrush>\n            <SolidColorBrush x:Key='ForegroundBrush'>Black</SolidColorBrush>\n        </ResourceDictionary>\n        <ResourceDictionary x:Key='Dark'>\n            <SolidColorBrush x:Key='BackgroundBrush'>Black</SolidColorBrush>\n            <SolidColorBrush x:Key='ForegroundBrush'>White</SolidColorBrush>\n        </ResourceDictionary>\n    </ResourceDictionary.ThemeDictionaries>\n</ResourceDictionary>\n"})}),"\n",(0,o.jsx)(r.h2,{id:"resource-dictionary-files",children:"Resource Dictionary Files"}),"\n",(0,o.jsxs)(r.p,{children:["You can improve the organisation of your ",(0,o.jsx)(r.em,{children:"Avalonia UI"})," application project by defining resource dictionaries in their own files. This makes resource definitions easy to locate and maintain."]}),"\n",(0,o.jsx)(r.p,{children:"Resources located in a resource dictionary file are accessible to the entire application."}),"\n",(0,o.jsx)(r.p,{children:"To add a resource dictionary file, follow this procedure:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Right-click your project at the location where you want the new file created."}),"\n",(0,o.jsxs)(r.li,{children:["Click ",(0,o.jsx)(r.strong,{children:"Add"}),", then ",(0,o.jsx)(r.strong,{children:"New Item"}),"."]}),"\n",(0,o.jsxs)(r.li,{children:["Click ",(0,o.jsx)(r.strong,{children:"Avalonia"})," in the list on the left:"]}),"\n"]}),"\n",(0,o.jsx)("img",{src:"/img/gitbook-import/assets/image (8) (1) (2).png",alt:""}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:["Click ",(0,o.jsx)(r.strong,{children:"Resource Dictionary (Avalonia)"}),"."]}),"\n",(0,o.jsx)(r.li,{children:"Type the file name you want to use."}),"\n",(0,o.jsxs)(r.li,{children:["Click ",(0,o.jsx)(r.strong,{children:"Add"}),"."]}),"\n"]}),"\n",(0,o.jsx)(r.admonition,{type:"note",children:(0,o.jsxs)(r.p,{children:["After the resource file is created you have to correctly include it into your application. See ",(0,o.jsx)(r.a,{href:"#include-and-merge-resources",children:"Include and Merge Resources"})," section."]})}),"\n",(0,o.jsx)(r.p,{children:"You can now add the resources you want to define in the position indicated. It looks like this:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<ResourceDictionary xmlns="https://github.com/avaloniaui"\n                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">\n    \x3c!-- Add Resources Here --\x3e\n</ResourceDictionary>\n'})}),"\n",(0,o.jsx)(r.h2,{id:"using-resources",children:"Using Resources"}),"\n",(0,o.jsxs)(r.p,{children:["You can use a resource from a resources dictionary that is in scope using the ",(0,o.jsx)(r.code,{children:"{DynamicResource}"})," mark-up extension."]}),"\n",(0,o.jsx)(r.p,{children:"For example, to use a resource directly on the background attribute of a border element, use the following XAML :"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<Border Background="{DynamicResource Warning}">\n  Look out!\n</Border>\n'})}),"\n",(0,o.jsx)(r.h3,{id:"static-resource",children:"Static Resource"}),"\n",(0,o.jsxs)(r.p,{children:["Alternatively you can choose to use the ",(0,o.jsx)(r.code,{children:"StaticResource"})," mark-up extension. For example:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<Border Background="{StaticResource Warning}">\n  Look out!\n</Border>\n'})}),"\n",(0,o.jsx)(r.p,{children:"A static resource is different in that it will not respond to changes in the resource made in code (at runtime). Once loaded a static cannot be altered."}),"\n",(0,o.jsx)(r.p,{children:"The benefit of using a static resource is that it has less work to do so it will be slightly faster to load, and it uses slightly less memory."}),"\n",(0,o.jsx)(r.h2,{id:"resource-priority",children:"Resource Priority"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.em,{children:"Avalonia UI"})," resolves what resource to use by searching upwards in the ",(0,o.jsx)(r.strong,{children:"logical control tree"})," from the level of a ",(0,o.jsx)(r.code,{children:"DynamicResource"})," or ",(0,o.jsx)(r.code,{children:"StaticResource"})," mark-up, looking for the resource key."]}),"\n",(0,o.jsx)(r.p,{children:"This means that resources with the same key have priority based on their proximity to the resource mark-up being resolved. Resource definitions further up the logical control tree are therefore effectively 'overridden' by those that are closer. For example, consider this XAML:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<UserControl ... >\n  <UserControl.Resources>\n    <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush>\n  </UserControl.Resources>\n\n  <StackPanel>\n    <StackPanel.Resources>\n      <SolidColorBrush x:Key="Warning">Orange</SolidColorBrush>\n    </StackPanel.Resources>\n\n    <Border Background="{DynamicResource Warning}">\n      Look out!\n    </Border>\n  </StackPanel>\n</UserControl>\n'})}),"\n",(0,o.jsxs)(r.p,{children:["Here the border control is using the resource with the key 'Warning'. This is defined twice - once at the level of the enclosing stack panel, and again at user control level. ",(0,o.jsx)(r.em,{children:"Avalonia UI"})," will determine that the border background should be be orange because its parent stack panel is first in a search upwards in the logical control tree from the border itself."]}),"\n",(0,o.jsx)(r.h2,{id:"include-and-merge-resources",children:"Include and Merge Resources"}),"\n",(0,o.jsx)(r.p,{children:"Resources can be included from a resource dictionary file, and merged with the resources defined in another file (even if there are not any)."}),"\n",(0,o.jsx)("img",{src:"/img/gitbook-import/assets/image (1) (4).png",alt:""}),"\n",(0,o.jsxs)(r.p,{children:["In case, if you would like to merge resource dictionary on the whole application level, you have to declare a resource dictionary in the in the ",(0,o.jsx)(r.strong,{children:"Application.Resources"})," section of application XAML ",(0,o.jsx)(r.strong,{children:"App.axaml"})," file, like this"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<Application.Resources>\n  <ResourceDictionary>\n    <ResourceDictionary.MergedDictionaries>\n      <MergeResourceInclude Source="/Assets/AppResources.axaml" />\n    </ResourceDictionary.MergedDictionaries>\n  </ResourceDictionary>\n</Application.Resources>\n'})}),"\n",(0,o.jsx)(r.p,{children:"You can also merge resource dictionary to declare merged resources to be specific to a style."}),"\n",(0,o.jsx)("img",{src:"/img/gitbook-import/assets/image (1) (3).png",alt:""}),"\n",(0,o.jsx)(r.p,{children:"This means that you can implement styles in one file, and use resources defined in another. This keeps your styling consistent, and your application solution well organised and easy to maintain."}),"\n",(0,o.jsx)(r.p,{children:"To include the resources dictionary from a file in a styles file, add the following XAML:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<Styles.Resources>\n    <ResourceDictionary>\n      <ResourceDictionary.MergedDictionaries>\n        <ResourceInclude Source="/Assets/AppResources.axaml"/>\n      </ResourceDictionary.MergedDictionaries>\n    </ResourceDictionary>\n  </Styles.Resources>\n'})}),"\n",(0,o.jsxs)(r.p,{children:["In the above examples, the resources file ",(0,o.jsx)(r.code,{children:"AppResources.axaml"})," is located in the ",(0,o.jsx)(r.code,{children:"/Assets"})," project folder. You can then define the styles using the resources, for example:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<Style Selector="Button.btn-info">\n    <Setter Property="Background" Value="{StaticResource InfoColor}"/>\n</Style>\n'})}),"\n",(0,o.jsxs)(r.p,{children:["Where the resource ",(0,o.jsx)(r.code,{children:"InfoColor"})," is defined as a ",(0,o.jsx)(r.code,{children:"SolidColorBrush"})," in the imported file."]}),"\n",(0,o.jsx)(r.admonition,{type:"info",children:(0,o.jsxs)(r.p,{children:["Note that the resource has been referenced using ",(0,o.jsx)(r.code,{children:"StaticResource"})," because it must not change - the requirement here is to keep the styling consistent."]})}),"\n",(0,o.jsx)(r.h2,{id:"merged-resources-priority",children:"Merged Resources Priority"}),"\n",(0,o.jsx)(r.p,{children:"As you saw previously, resources are resolved by searching up the logical control tree from the point of mark-up until a resource with the requested key is found."}),"\n",(0,o.jsx)(r.p,{children:"However the presence of styles and merged dictionaries defined at the various levels of an application, introduces extra priority rules as follows:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Control resources -> Merged dictionaries"}),"\n",(0,o.jsx)(r.li,{children:"Style resources -> Merged dictionaries"}),"\n",(0,o.jsx)(r.li,{children:"App resources -> Merged dictionaries"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:["For example, in the theoretical application below, the search for a resource used on the border control (at the bottom) will follow the order indicated in square ",(0,o.jsx)(r.code,{children:"[]"})," brackets:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"Application\n |- Resources [11]\n     |- Merged dictionary [12]\n     |- Merged dictionary [13]\n |- Styles\n     |- Resources [14]\n         |- Merged dictionary [15]\n         |- Merged dictionary [16]\n\nWindow\n |- Resources [6]\n     |- Merged dictionary [7]\n |- Styles\n     |- Resources [8]\n         |- Merged dictionary [9]\n         |- Merged dictionary [10]\n |- StackPanel\n     |- Resources [1]\n         |- Merged dictionary [2]\n         |- Merged dictionary [3]\n     |- Styles\n         |- Resources [4]\n             |- Merged dictionary [5]\n     |- Border\n"})}),"\n",(0,o.jsx)(r.p,{children:"Starting at the border, the first resources searched are any defined in the parent (stack panel) control. After that any merged dictionaries at the same level are considered - in the sequence that they appear in the XAML."}),"\n",(0,o.jsx)(r.p,{children:"The search then moves on to search any styles defined in the parent (stack panel) control, followed by any merged dictionaries at that level."}),"\n",(0,o.jsx)(r.p,{children:"The search moves upwards in the logical control tree, behaving at each level in a similar manner. It finally reaches application-level resources and styles."}),"\n",(0,o.jsx)(r.h2,{id:"consuming-resources-from-code",children:"Consuming Resources from code"}),"\n",(0,o.jsx)(r.p,{children:"Avalonia provides different options to access Resources from code."}),"\n",(0,o.jsx)(r.admonition,{type:"note",children:(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.code,{children:"ResourceNode"})," in the below samples can be any node that supports ",(0,o.jsx)(r.code,{children:"Resource"}),", like ",(0,o.jsx)(r.code,{children:"Application.Current"}),", ",(0,o.jsx)(r.code,{children:"Window"}),", ",(0,o.jsx)(r.code,{children:"UserControl"}),", ..."]})}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:'ResourceNode.Resources["TheKey"]'}),": ",(0,o.jsx)("br",{}),"\nThis will directly access the underlying ",(0,o.jsx)(r.code,{children:"Dictionary"}),". Be aware: Merged Dictionaries and parents will not be scanned."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"ResourceNode.TryGetResource"}),": ",(0,o.jsx)("br",{}),"\nThis function will try to get a specific resource and return ",(0,o.jsx)(r.code,{children:"true"})," if successful, otherwise ",(0,o.jsx)(r.code,{children:"false"}),". Merged dictionaries will be scanned, but it will not follow the logical tree."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"ResourceNode.TryFindResource"}),":  ",(0,o.jsx)("br",{}),"\nThis extension method will try to get a specific resource and return ",(0,o.jsx)(r.code,{children:"true"})," if successful, otherwise ",(0,o.jsx)(r.code,{children:"false"}),". Merged dictionaries and the logical tree will be scanned as well."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"ResourceNode.GetResourceObservable"}),": ",(0,o.jsx)("br",{}),"\nThis will return an ",(0,o.jsx)(r.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/System.IObservable-1",children:(0,o.jsx)(r.code,{children:"IObservable"})})," which can be used to observe changes on the resource. For example you could bind to it."]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-cs",children:'// In this sample we have defined the resource in App.axaml and we want to look up the value in the MainWindow constructor.\n//\n//    </Application.Resources>\n//         <x:String x:Key="TheKey">HelloWorld</x:String>\n//    </Application.Resources>\n\npublic MainWindow()\n{\n    InitializeComponent();\n\n    // found1 = false | result1 = null\n    var found1 = this.TryGetResource("TheKey", this.ActualThemeVariant, out var result1);\n\n    // found2 = true | result2 = "Hello World" \n    var found2 = this.TryFindResource("TheKey", this.ActualThemeVariant, out var result2);\n\n    // Bind the resource to a TextBlock from code behind\n    myTextBlock.Bind(TextBlock.TextProperty, Resources.GetResourceObservable("TheKey"));\n\n    // This will update myTextBlock.Text via the bound observable\n    this.Resources["TheKey"] = "Hello from code behind"; \n}\n'})})]})}function u(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>c});var s=n(96540);const o={},i=s.createContext(o);function t(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);