"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[1027],{11208:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>d,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/data-binding/how-to-bind-multiple-properties","title":"How to Bind Multiple Properties","description":"MultiBinding","source":"@site/docs/guides/data-binding/how-to-bind-multiple-properties.md","sourceDirName":"guides/data-binding","slug":"/guides/data-binding/how-to-bind-multiple-properties","permalink":"/avalonia-docs-ko/docs/guides/data-binding/how-to-bind-multiple-properties","draft":false,"unlisted":false,"editUrl":"https://github.com/202420505/avalonia-docs-ko/tree/main/docs/guides/data-binding/how-to-bind-multiple-properties.md","tags":[],"version":"current","lastUpdatedBy":"Q","lastUpdatedAt":1755602518000,"frontMatter":{"id":"how-to-bind-multiple-properties","title":"How to Bind Multiple Properties"},"sidebar":"documentationSidebar","previous":{"title":"How to Create a Custom Data Binding Converter","permalink":"/avalonia-docs-ko/docs/guides/data-binding/how-to-create-a-custom-data-binding-converter"},"next":{"title":"How To Bind Tabs","permalink":"/avalonia-docs-ko/docs/guides/data-binding/how-to-bind-tabs"}}');var o=i(74848),r=i(28453);const l=i.p+"assets/images/multibinding-rgb-e99dc0f20485f69304c38c9edc8313dc.gif",a={id:"how-to-bind-multiple-properties",title:"How to Bind Multiple Properties"},d=void 0,s={},c=[{value:"MultiBinding",id:"multibinding",level:2},{value:"IMultiValueConverter",id:"imultivalueconverter",level:2},{value:"MultiBinding Example",id:"multibinding-example",level:2}];function u(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"multibinding",children:"MultiBinding"}),"\n",(0,o.jsxs)(n.p,{children:["In scenarios where a target property must be assigned a result calculated from several other bound properties, a\n",(0,o.jsx)(n.code,{children:"MultiBinding"})," may be the appropriate solution. ",(0,o.jsx)(n.code,{children:"MultiBinding"})," aggregates multiple ",(0,o.jsx)(n.code,{children:"Binding"})," objects and produces a result\nthrough the use of an ",(0,o.jsx)(n.code,{children:"IMultiValueConverter"}),". The ",(0,o.jsx)(n.code,{children:"Convert"})," method is called each time any of the bound properties notify\nof change. Similar to ",(0,o.jsx)(n.code,{children:"Binding"}),", ",(0,o.jsx)(n.code,{children:"MultiBinding"})," can be used to bind properties on ViewModels, ",(0,o.jsx)(n.code,{children:"Control"}),"s, or other sources."]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"MultiBinding"})," only supports ",(0,o.jsx)(n.code,{children:"BindingMode.OneTime"})," and ",(0,o.jsx)(n.code,{children:"BindingMode.OneWay"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"imultivalueconverter",children:"IMultiValueConverter"}),"\n",(0,o.jsxs)(n.p,{children:["Similar to ",(0,o.jsx)(n.code,{children:"IValueConverter"})," in that it defines conversions to a target property. There is no ",(0,o.jsx)(n.code,{children:"ConvertBack"}),"\nmethod as aggregate operations are irreversible."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public interface IMultiValueConverter\n{\n    object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture);\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"multibinding-example",children:"MultiBinding Example"}),"\n",(0,o.jsxs)(n.p,{children:["Consider the following scenario where you have inputs for red, green, and blue color channels. The aim is to bind\nall 3 inputs and provide an ",(0,o.jsx)(n.code,{children:"IBrush"})," for another control to draw with. Below, the color channel values are constrained\nto the proper range ([0, 255]) by the ",(0,o.jsx)(n.code,{children:"NumericUpDown"}),". Creating ",(0,o.jsx)(n.code,{children:"<Binding>"})," objects is necessary as the ",(0,o.jsx)(n.code,{children:"Binding"}),"\n",(0,o.jsx)(n.code,{children:"MarkupExtension"})," cannot be used because there aren't properties to target."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<StackPanel HorizontalAlignment="Center" VerticalAlignment="Center" Spacing="8">\n    <NumericUpDown x:Name="red" Minimum="0" Maximum="255" Increment="20" Value="0" Foreground="Red" />\n    <NumericUpDown x:Name="green" Minimum="0" Maximum="255" Increment="20" Value="0" Foreground="Green" />\n    <NumericUpDown x:Name="blue" Minimum="0" Maximum="255" Increment="20" Value="0" Foreground="Blue" />\n\n    <TextBlock Text="MultiBinding Text Color!" FontSize="24">\n        <TextBlock.Foreground>\n            <MultiBinding Converter="{StaticResource RgbToBrushMultiConverter}">\n                <Binding Path="Value" ElementName="red" />\n                <Binding Path="Value" ElementName="green" />\n                <Binding Path="Value" ElementName="blue" />\n            </MultiBinding>\n        </TextBlock.Foreground>\n    </TextBlock>\n</StackPanel>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Next, we create the ",(0,o.jsx)(n.code,{children:"IMultiValueConverter"}),". Type checking of parameters is important. In this scenario, ",(0,o.jsx)(n.code,{children:"NumericUpDown.Value"}),"\nis a ",(0,o.jsx)(n.code,{children:"decimal?"})," so both ",(0,o.jsx)(n.code,{children:"decimal"})," and ",(0,o.jsx)(n.code,{children:"null"})," must be checked. The value may also be ",(0,o.jsx)(n.code,{children:"UnsetValueType"})," when the bindings are\nbeing initialized. Further numeric conversion could be done to make the converter broadly compatible with numeric types."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",metastring:"title='Converter Implementation'",children:"public sealed class RgbToBrushMultiConverter : IMultiValueConverter\n{\n    public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)\n    {\n        // Ensure all bindings are provided and attached to correct target type\n        if (values?.Count != 3 || !targetType.IsAssignableFrom(typeof(ImmutableSolidColorBrush)))\n            throw new NotSupportedException();\n\n        // Ensure all bindings are correct type\n        if (!values.All(x => x is decimal or UnsetValueType or null))\n            throw new NotSupportedException();\n\n        // Pull values, DoNothing if any are unset.\n        // Convert is called several times during initialization of bindings,\n        // so some properties will be initially unset.\n        if (values[0] is not decimal r ||\n            values[1] is not decimal g ||\n            values[2] is not decimal b)\n            return BindingOperations.DoNothing;\n\n        byte a = 255;\n        var color = new Color(a, (byte)r, (byte)g, (byte)b);\n        return new ImmutableSolidColorBrush(color);\n    }\n}\n"})}),"\n",(0,o.jsx)("img",{src:l,alt:""}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Consider creating a ",(0,o.jsx)(n.code,{children:"MarkupExtension"})," to simplify the XAML syntax when a ",(0,o.jsx)(n.code,{children:"MultiBinding"})," is frequently reused."]}),"\n",(0,o.jsxs)(n.li,{children:["Consider using ",(0,o.jsx)(n.code,{children:"FuncMultiValueConverter"})," to reduce the amount of code needed for simpler converters."]}),"\n"]})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var t=i(96540);const o={},r=t.createContext(o);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);