"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[96],{95256:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/platforms/platform-specific-code/dotnet","title":"Platform-specific .NET","description":"Overview","source":"@site/docs/guides/platforms/platform-specific-code/dotnet.md","sourceDirName":"guides/platforms/platform-specific-code","slug":"/guides/platforms/platform-specific-code/dotnet","permalink":"/docs/guides/platforms/platform-specific-code/dotnet","draft":false,"unlisted":false,"editUrl":"https://github.com/AvaloniaUI/avalonia-docs/tree/main/docs/guides/platforms/platform-specific-code/dotnet.md","tags":[],"version":"current","lastUpdatedBy":"202420505","lastUpdatedAt":1755588461000,"frontMatter":{"id":"dotnet","title":"Platform-specific .NET"},"sidebar":"documentationSidebar","previous":{"title":"Improving Performance","permalink":"/docs/guides/development-guides/improving-performance"},"next":{"title":"Platform-Specific XAML","permalink":"/docs/guides/platforms/platform-specific-code/xaml"}}');var r=t(74848),o=t(28453);const s={id:"dotnet",title:"Platform-specific .NET"},a=void 0,c={},d=[{value:"Overview",id:"overview",level:2},{value:"Runtime Conditions",id:"runtime-conditions",level:2},{value:"Conditional compilation",id:"conditional-compilation",level:2},{value:"Practical example",id:"practical-example",level:3},{value:"Platform specific projects",id:"platform-specific-projects",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Conditional compilation in .NET allows different parts of the code to be compiled or omitted based on certain conditions. This is particularly useful in .NET when dealing with code that needs to behave differently on various platforms or under different development environments."}),"\n",(0,r.jsx)(n.p,{children:"None of these solutions are specific to Avalonia, and they can be used with any type of projects."}),"\n",(0,r.jsx)(n.h2,{id:"runtime-conditions",children:"Runtime Conditions"}),"\n",(0,r.jsxs)(n.p,{children:[".NET 6 and newer provide a set of APIs to get operating system in runtime - ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.operatingsystem",children:"OperatingSystem"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Commonly used static methods of this class are:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IsWindows()"}),(0,r.jsx)(n.td,{children:"Indicates whether the current application is running on Windows."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IsLinux()"}),(0,r.jsx)(n.td,{children:"Indicates whether the current application is running on Linux."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IsMacOS()"}),(0,r.jsx)(n.td,{children:"Indicates whether the current application is running on macOS."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IsAndroid()"}),(0,r.jsx)(n.td,{children:"Indicates whether the current application is running on Android."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IsIOS()"}),(0,r.jsx)(n.td,{children:"Indicates whether the current application is running on iOS or MacCatalyst."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IsBrowser()"}),(0,r.jsx)(n.td,{children:"Indicates whether the current application is running as WASM in a browser."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IsOSPlatform(String)"}),(0,r.jsx)(n.td,{children:"Indicates whether the current application is running on the specified platform."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"These methods do not require any changes in the project structure, and can be used anywhere.\nThe disadvantage of using them, it is not possible to separate platform specific APIs in compile time. As otherwise it would require platform specific dependencies to be referenced in a common assembly."}),"\n",(0,r.jsx)(n.p,{children:"This approach is recommended for simpler scenarios, or when it's desired to keep simple project structure. In the last case,"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"It's the only possible approach to write a conditional .NET code for Linux OS. As .NET doesn't have a special Target Framework for Linux."})}),"\n",(0,r.jsx)(n.h2,{id:"conditional-compilation",children:"Conditional compilation"}),"\n",(0,r.jsxs)(n.p,{children:["C# specifically allows to have conditional compilation with ",(0,r.jsx)(n.code,{children:"#if"}),", ",(0,r.jsx)(n.code,{children:"#elif"}),", ",(0,r.jsx)(n.code,{children:"#else"}),", ",(0,r.jsx)(n.code,{children:"#endif"})," - ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives#conditional-compilation",children:"C# preprocessor directives"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"DEBUG"})," compile time constant is a well known one. But it's not really useful with writing platform specific code.\nDepending on the project time, C# compiler might define additional constants per each ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/frameworks#net-5-os-specific-tfms",children:"OS specific Target Framework"})," used in the project:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Target Framework"}),(0,r.jsx)(n.th,{children:"Constant"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"net8.0"}),(0,r.jsx)(n.td,{children:"-"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"net8.0-windows"}),(0,r.jsx)(n.td,{children:"WINDOWS"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"net8.0-macos"}),(0,r.jsx)(n.td,{children:"MACOS"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"net8.0-browser"}),(0,r.jsx)(n.td,{children:"BROWSER"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"net8.0-ios"}),(0,r.jsx)(n.td,{children:"IOS"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"net8.0-android"}),(0,r.jsx)(n.td,{children:"ANDROID"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"net8.0-tizen"}),(0,r.jsx)(n.td,{children:"TIZEN"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"From this table, we can see couple of notes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"If project doesn't use any OS specific Target Framework, none of these constants will be defined"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"There is no constant for LINUX"}),", as there is no ",(0,r.jsx)(n.code,{children:"net8.0-linux"})," Target Framework as of now. Note, it might be changed in the future versions of .NET."]}),"\n",(0,r.jsxs)(n.li,{children:["Additionally, ",(0,r.jsx)(n.code,{children:"net8.0-browser"})," is only available starting with .NET 8 SDK. Other Target Frameworks are supported with .NET 6 or higher."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Similar approach can be used to define special code compilation for .NET Framework or .NET Standard projects, if it's required. Visit Microsoft ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting",children:"Cross-platform targeting\n"})," documentation for more information."]})}),"\n",(0,r.jsx)(n.h3,{id:"practical-example",children:"Practical example"}),"\n",(0,r.jsxs)(n.p,{children:['Let\'s imagine, we want to use platform APIs from C# code. It can be Avalonia APIs, or Xamarin APIs, or anything else really.\nFirst of all, expected Target Frameworks needs to be defined in the project. To keep it simple, we will have three possible target framework - "net8.0" (default), "net8.0-ios" and "net8.0-android" in ',(0,r.jsx)(n.code,{children:".csproj"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<PropertyGroup>\n    <TargetFrameworks>net8.0;net8.0-ios;net8.0-android</TargetFrameworks>\n</PropertyGroup>\n"})}),"\n",(0,r.jsx)(n.p,{children:"And then it's possible to create a method like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public enum DeviceOrientation\n{\n    Undefined,\n    Landscape,\n    Portrait\n}\n\npublic static DeviceOrientation GetOrientation()\n{\n#if ANDROID\n            IWindowManager windowManager = Android.App.Application.Context.GetSystemService(Context.WindowService).JavaCast<IWindowManager>();\n            SurfaceOrientation orientation = windowManager.DefaultDisplay.Rotation;\n            bool isLandscape = orientation == SurfaceOrientation.Rotation90 || orientation == SurfaceOrientation.Rotation270;\n            return isLandscape ? DeviceOrientation.Landscape : DeviceOrientation.Portrait;\n#elif IOS\n            UIInterfaceOrientation orientation = UIApplication.SharedApplication.StatusBarOrientation;\n            bool isPortrait = orientation == UIInterfaceOrientation.Portrait || orientation == UIInterfaceOrientation.PortraitUpsideDown;\n            return isPortrait ? DeviceOrientation.Portrait : DeviceOrientation.Landscape;\n#else\n            return DeviceOrientation.Undefined;\n#endif\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["This sample code is referenced from the Microsoft documentation: ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/invoke-platform-code?view=net-maui-8.0#conditional-compilation",children:"https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/invoke-platform-code?view=net-maui-8.0#conditional-compilation"})]})}),"\n",(0,r.jsx)(n.h2,{id:"platform-specific-projects",children:"Platform specific projects"}),"\n",(0,r.jsx)(n.p,{children:"Similarly to the previous approach, it is possible to create bootstrap projects per each platform, and keep shared project with main logic and layouts.\nFor example, default Avalonia.Xplat template creates solution with following projects:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Project"}),(0,r.jsx)(n.th,{children:"Target Framework"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Project.Shared"}),(0,r.jsx)(n.td,{children:"net8.0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Project.Desktop"}),(0,r.jsx)(n.td,{children:"net8.0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Project.Android"}),(0,r.jsx)(n.td,{children:"net8.0-android"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Project.iOS"}),(0,r.jsx)(n.td,{children:"net8.0-ios"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Project.Browser"}),(0,r.jsx)(n.td,{children:"net8.0-browser"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Desktop project combines Windows, macOS and Linux. While mobile and browser platforms have their own projects.\nThis is default approach for Avalonia projects. If desired, developers can split Desktop project into multiple as well.\nAlthough, it should be kept in mind, that .NET SDK doesn't have any target framework for Linux yet, so it still would have to use generic ",(0,r.jsx)(n.code,{children:"net8.0"})," target framework."]}),"\n",(0,r.jsx)(n.p,{children:"Commonly, when any platform specific code is required, a new interface is created in shared project, with different implementations per each platform.\nAdapting previous sample would look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"title='Project.Shared IDeviceOrientation.cs'",children:"public interface IDeviceOrientation\n{\n    DeviceOrientation GetOrientation();\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"title='Project.Android AndroidDeviceOrientation.cs'",children:"public class AndroidDeviceOrientation : IDeviceOrientation\n{\n    public DeviceOrientation GetOrientation()\n    {\n        IWindowManager windowManager = Android.App.Application.Context.GetSystemService(Context.WindowService).JavaCast<IWindowManager>();\n        SurfaceOrientation orientation = windowManager.DefaultDisplay.Rotation;\n        bool isLandscape = orientation == SurfaceOrientation.Rotation90 || orientation == SurfaceOrientation.Rotation270;\n        return isLandscape ? DeviceOrientation.Landscape : DeviceOrientation.Portrait;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"title='Project.iOS iOSDeviceOrientation.cs'",children:"public class iOSDeviceOrientation : IDeviceOrientation\n{\n    public DeviceOrientation GetOrientation()\n    {\n        UIInterfaceOrientation orientation = UIApplication.SharedApplication.StatusBarOrientation;\n        bool isPortrait = orientation == UIInterfaceOrientation.Portrait || orientation == UIInterfaceOrientation.PortraitUpsideDown;\n        return isPortrait ? DeviceOrientation.Portrait : DeviceOrientation.Landscape;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Each implementation then can be registered using dependency injection library of choice, or using a static registry property."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);