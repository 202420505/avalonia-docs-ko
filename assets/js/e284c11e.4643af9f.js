"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[8312],{87017:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>s});const i=JSON.parse('{"id":"concepts/reactiveui/binding-to-sorted-filtered-list","title":"Binding to Sorted/Filtered Data","description":"CONCEPTS - ReactiveUI","source":"@site/docs/concepts/reactiveui/binding-to-sorted-filtered-list.md","sourceDirName":"concepts/reactiveui","slug":"/concepts/reactiveui/binding-to-sorted-filtered-list","permalink":"/docs/concepts/reactiveui/binding-to-sorted-filtered-list","draft":false,"unlisted":false,"editUrl":"https://github.com/AvaloniaUI/avalonia-docs/tree/main/docs/concepts/reactiveui/binding-to-sorted-filtered-list.md","tags":[],"version":"current","lastUpdatedBy":"202420505","lastUpdatedAt":1755588461000,"frontMatter":{"description":"CONCEPTS - ReactiveUI"},"sidebar":"documentationSidebar","previous":{"title":"Data Persistence","permalink":"/docs/concepts/reactiveui/data-persistence"},"next":{"title":"Services","permalink":"/docs/concepts/services/"}}');var o=n(74848),r=n(28453);const c={description:"CONCEPTS - ReactiveUI"},a="Binding to Sorted/Filtered Data",d={},s=[{value:"Creating a Source Cache",id:"creating-a-source-cache",level:2},{value:"Creating Sorted Or Filtered Views",id:"creating-sorted-or-filtered-views",level:2},{value:"Binding",id:"binding",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"binding-to-sortedfiltered-data",children:"Binding to Sorted/Filtered Data"})}),"\n",(0,o.jsxs)(t.p,{children:["A common UI task that applications need to do is display sorted and/or filtered 'views' of data. In Avalonia this can be accomplished by connecting a ",(0,o.jsx)(t.code,{children:"SourceCache<TObject, TKey>"})," or a ",(0,o.jsx)(t.code,{children:"SourceList<T>"})," to a ",(0,o.jsx)(t.code,{children:"ReadOnlyObservableCollection<T>"})," and binding to that collection"]}),"\n",(0,o.jsx)(t.h2,{id:"creating-a-source-cache",children:"Creating a Source Cache"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"SourceCache<TObject, TKey>"})," or ",(0,o.jsx)(t.code,{children:"SourceList<T>"})," come from ",(0,o.jsx)(t.a,{href:"https://www.reactiveui.net/docs/handbook/collections/",children:"Dynamic Data in ReactiveUI"})," Example:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"// (x => x.Id) property that serves as the unique key for the cache\nprivate SourceCache<TestViewModel, Guid> _sourceCache = new (x => x.Id);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Then the ",(0,o.jsx)(t.code,{children:"_sourceCache"})," can be populated through the ",(0,o.jsx)(t.code,{children:"AddOrUpdate"})," method"]}),"\n",(0,o.jsx)(t.h2,{id:"creating-sorted-or-filtered-views",children:"Creating Sorted Or Filtered Views"}),"\n",(0,o.jsxs)(t.p,{children:["Next the ",(0,o.jsx)(t.code,{children:"ReadOnlyObservableCollection<T>"})," can be bound to the filtered or sorted ",(0,o.jsx)(t.code,{children:"_sourceCache"}),". The sorting/filtering is done similarly to Linq."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"private readonly ReadOnlyObservableCollection<TestViewModel> _testViewModels;\npublic ReadOnlyObservableCollection<TestViewModel> TestViewModels => _testViewModels;\n...\npublic MainWindowViewModel(){\n    // Populate the source cache via _sourceCache.AddOrUpdate\n    ...\n    _sourceCache.Connect()\n        // Sort Ascending on the OrderIndex property\n        .Sort(SortExpressionComparer<TestViewModel>.Ascending(t => t.OrderIndex))\n        .Filter(x => x.Id.ToString().EndsWith('1'))\n        // Bind to our ReadOnlyObservableCollection<T>\n        .Bind(out _testViewModels)\n        // Subscribe for changes\n        .Subscribe();\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"binding",children:"Binding"}),"\n",(0,o.jsxs)(t.p,{children:["Now that the ",(0,o.jsx)(t.code,{children:"_sourceCache"})," is created and populated and the ",(0,o.jsx)(t.code,{children:"ReadOnlyObservableCollection<T>"})," is created and bound we can go into our view and bind exactly the way we normally would with an ",(0,o.jsx)(t.code,{children:"ObservableCollection<T>"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-xml",children:'<Design.DataContext>\n    <vm:MainWindowViewModel/>\n</Design.DataContext>\n\n<TreeView ItemsSource="{Binding TestViewModels}">\n    <TreeView.DataTemplates>\n        !-- DataTemplate Definitions --\x3e\n    </TreeView.DataTemplates> \n</TreeView>\n'})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>a});var i=n(96540);const o={},r=i.createContext(o);function c(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);