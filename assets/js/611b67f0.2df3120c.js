"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[8226],{67151:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>r});const n=JSON.parse('{"id":"concepts/view-locator","title":"The View Locator","description":"CONCEPTS","source":"@site/docs/concepts/view-locator.md","sourceDirName":"concepts","slug":"/concepts/view-locator","permalink":"/avalonia-docs-ko/docs/concepts/view-locator","draft":false,"unlisted":false,"editUrl":"https://github.com/202420505/avalonia-docs-ko/tree/main/docs/concepts/view-locator.md","tags":[],"version":"current","lastUpdatedBy":"Q","lastUpdatedAt":1755590087000,"frontMatter":{"description":"CONCEPTS"},"sidebar":"documentationSidebar","previous":{"title":"The TopLevel","permalink":"/avalonia-docs-ko/docs/concepts/toplevel"},"next":{"title":"Deployment","permalink":"/avalonia-docs-ko/docs/deployment/"}}');var i=o(74848),a=o(28453);const s={description:"CONCEPTS"},c="The View Locator",l={},r=[{value:"How it works",id:"how-it-works",level:2},{value:"Customizing the View Locator",id:"customizing-the-view-locator",level:2},{value:"Using the View Locator",id:"using-the-view-locator",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"the-view-locator",children:"The View Locator"})}),"\n",(0,i.jsx)(t.p,{children:"While the use of the View Locator comes as part of the default templates, it's important to note that it's not a mandatory requirement. It's an optional tool provided to help you structure your Avalonia application using the Model-View-ViewModel (MVVM) design pattern."}),"\n",(0,i.jsx)(t.p,{children:"The View Locator is a mechanism in Avalonia that is used to resolve the view (user interface) that corresponds to a specific ViewModel. This is a core part of the MVVM (Model-View-ViewModel) pattern, which is a design pattern that separates the development of the graphical user interface from the development of the business logic or back-end logic."}),"\n",(0,i.jsx)(t.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsx)(t.p,{children:'The View Locator uses naming conventions to map ViewModel types to view types. By default, it replaces every occurrence of the string "ViewModel" within the fully-qualified ViewModel type name with "View".'}),"\n",(0,i.jsxs)(t.p,{children:["For example, given a ViewModel named ",(0,i.jsx)(t.code,{children:"MyApplication.ViewModels.ExampleViewModel"}),", the View Locator will look for a View named ",(0,i.jsx)(t.code,{children:"MyApplication.Views.ExampleView"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The View Locator is typically used in conjunction with the ",(0,i.jsx)(t.code,{children:"DataContext"})," property, which is used to link a view to its ViewModel."]}),"\n",(0,i.jsx)(t.p,{children:"Here's a simple usage example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:'public class ViewLocator : IDataTemplate\n{\n    public bool SupportsRecycling => false;\n\n    public Control Build(object data)\n    {\n        var name = data.GetType().FullName.Replace("ViewModel", "View");\n        var type = Type.GetType(name);\n\n        if (type != null)\n        {\n            return (Control)Activator.CreateInstance(type);\n        }\n        else\n        {\n            return new TextBlock { Text = "Not Found: " + name };\n        }\n    }\n\n    public bool Match(object data)\n    {\n        return data is ViewModelBase;\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In this example, the View Locator is implemented as an ",(0,i.jsx)(t.code,{children:"IDataTemplate"}),". The ",(0,i.jsx)(t.code,{children:"Build"})," method creates the view for the ViewModel, and the ",(0,i.jsx)(t.code,{children:"Match"})," method checks if the data object is a ViewModel that this locator knows how to handle. If you do not have a ",(0,i.jsx)(t.code,{children:"ViewModelBase"})," class, at a minimum your ViewModel must implement ",(0,i.jsx)(t.code,{children:"INotifyPropertyChanged"}),", and the comparison in ",(0,i.jsx)(t.code,{children:"Match"})," should be changed accordingly."]}),"\n",(0,i.jsx)(t.h2,{id:"customizing-the-view-locator",children:"Customizing the View Locator"}),"\n",(0,i.jsxs)(t.p,{children:["You can customize the View Locator to use different conventions. For example, you might want to look for views in a different assembly, or use a different naming convention. To do this, you can implement your own View Locator by creating a class that implements the ",(0,i.jsx)(t.code,{children:"IDataTemplate"})," interface, and replace the default View Locator with your own."]}),"\n",(0,i.jsx)(t.h2,{id:"using-the-view-locator",children:"Using the View Locator"}),"\n",(0,i.jsxs)(t.p,{children:["By default, the View Locator is referenced in App.axaml as a DataTemplate, in the content of the ",(0,i.jsx)(t.code,{children:"Application.DataTemplates"})," XAML tag. Ensure that its appropriate 'using' statement is in the ",(0,i.jsx)(t.code,{children:"xmlns:local"})," property of the Application root tag."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-xml",children:'<Application xmlns="https://github.com/avaloniaui"\n             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"\n             x:Class="LearningAvalonia.App"\n             xmlns:local="using:LearningAvalonia"\n             RequestedThemeVariant="Default">\n             \x3c!-- "Default" ThemeVariant follows system theme variant. "Dark" or "Light" are other available options. --\x3e\n    <Application.DataTemplates>\n        <local:ViewLocator />\n    </Application.DataTemplates>\n\n    <Application.Styles>\n        <FluentTheme />\n    </Application.Styles>\n</Application>\n'})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>c});var n=o(96540);const i={},a=n.createContext(i);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);