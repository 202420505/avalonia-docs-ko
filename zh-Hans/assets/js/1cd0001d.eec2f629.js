"use strict";(self.webpackChunkavalonia_docs=self.webpackChunkavalonia_docs||[]).push([[5084],{13699:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/platforms/platform-specific-code/xaml","title":"Platform-Specific XAML","description":"OnPlatform Markup Extension","source":"@site/docs/guides/platforms/platform-specific-code/xaml.md","sourceDirName":"guides/platforms/platform-specific-code","slug":"/guides/platforms/platform-specific-code/xaml","permalink":"/zh-Hans/docs/guides/platforms/platform-specific-code/xaml","draft":false,"unlisted":false,"editUrl":"https://github.com/AvaloniaUI/avalonia-docs/tree/main/docs/guides/platforms/platform-specific-code/xaml.md","tags":[],"version":"current","lastUpdatedBy":"202420505","lastUpdatedAt":1755588461000,"frontMatter":{"id":"xaml","title":"Platform-Specific XAML"},"sidebar":"documentationSidebar","previous":{"title":"Platform-specific .NET","permalink":"/zh-Hans/docs/guides/platforms/platform-specific-code/dotnet"},"next":{"title":"Android","permalink":"/zh-Hans/docs/guides/platforms/android/"}}');var o=t(74848),a=t(28453);const l={id:"xaml",title:"Platform-Specific XAML"},s=void 0,r={},c=[{value:"OnPlatform Markup Extension",id:"onplatform-markup-extension",level:2},{value:"Overview",id:"overview",level:3},{value:"Basic usage in markup extension syntax",id:"basic-usage-in-markup-extension-syntax",level:3},{value:"Specifying Type Arguments",id:"specifying-type-arguments",level:3},{value:"Nested Markup Extensions",id:"nested-markup-extensions",level:3},{value:"XML Syntax",id:"xml-syntax",level:3},{value:"Complex Property Setters",id:"complex-property-setters",level:3},{value:"XML Combining Syntax",id:"xml-combining-syntax",level:3},{value:"Additional details",id:"additional-details",level:3},{value:"OnFormFactor Markup Extension",id:"onformfactor-markup-extension",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"onplatform-markup-extension",children:"OnPlatform Markup Extension"}),"\n",(0,o.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"The OnPlatform markup extension in Avalonia allows developers to specify different values for a property based on the operating system on which the application is running. This is particularly useful for creating cross-platform applications that need to adapt their UI or behavior according to the platform."}),"\n",(0,o.jsx)(n.h3,{id:"basic-usage-in-markup-extension-syntax",children:"Basic usage in markup extension syntax"}),"\n",(0,o.jsx)(n.p,{children:"You can specify values for each platform and a default value that will be used if no specific platform match is found:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<TextBlock Text=\"{OnPlatform Default='Unknown', Windows='Im Windows', macOS='Im macOS', Linux='Im Linux'}\"/>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively, you can use constructor syntax to define the default value directly, skipping ",(0,o.jsx)(n.code,{children:"Default"})," keyword. Platform-specific properties still need to be defined:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<TextBlock Text=\"{OnPlatform 'Hello World', Android='Im Android'}\"/>\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can use this markup extension with any other type, not only strings:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<Border Height="{OnPlatform 10, Windows=50.5}"/>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"specifying-type-arguments",children:"Specifying Type Arguments"}),"\n",(0,o.jsx)(n.p,{children:"You can use custom TypeArguments to explicitly specify the type for the values:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<TextBlock Tag=\"{OnPlatform '0, 0, 0, 0', Windows='10, 10, 10, 10', x:TypeArguments=Thickness}\"/>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this sample above, ",(0,o.jsx)(n.code,{children:"Tag"})," property has type of ",(0,o.jsx)(n.code,{children:"object"}),", so compiler doesn't have enough information to parse input strings. Without specifying TypeArguments, property will have value of ",(0,o.jsx)(n.code,{children:"string"})," on all platforms. But since we have ",(0,o.jsx)(n.code,{children:"TypeArguments"})," here, compiler will parse them as ",(0,o.jsx)(n.code,{children:"Thickness"})," values."]}),"\n",(0,o.jsx)(n.h3,{id:"nested-markup-extensions",children:"Nested Markup Extensions"}),"\n",(0,o.jsx)(n.p,{children:"The OnPlatform extension supports nesting other markup extensions within it:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<Border Background="{OnPlatform Default={StaticResource DefaultBrush}, Windows={StaticResource WindowsBrush}}"/>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"xml-syntax",children:"XML Syntax"}),"\n",(0,o.jsx)(n.p,{children:"OnPlatform can also be used in XML syntax for defining property values:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<StackPanel>\n    <OnPlatform>\n        <OnPlatform.Default>\n            <ToggleButton Content="Hello World" />\n        </OnPlatform.Default>\n        <OnPlatform.iOS>\n            <ToggleSwitch Content="Hello iOS" />\n        </OnPlatform.Windows>\n    </OnPlatform>\n</StackPanel>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note, in this sample, ",(0,o.jsx)(n.code,{children:"OnPlatform"})," is a child of ",(0,o.jsx)(n.code,{children:"StackPanel"}),". But in runtime only single actual control will be created (",(0,o.jsx)(n.code,{children:"ToggleButton"})," or ",(0,o.jsx)(n.code,{children:"ToggleSwitch"}),") and added to the StackPanel."]}),"\n",(0,o.jsx)(n.h3,{id:"complex-property-setters",children:"Complex Property Setters"}),"\n",(0,o.jsx)(n.p,{children:"Similarly to the previous sample, OnPlatform can be part of complex property setters within a ResourceDictionary or other dictionaries or collections:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<ResourceDictionary>\n    <OnPlatform x:Key="MyBrush">\n        <OnPlatform.Default>\n            <SolidColorBrush Color="Blue" />\n        </OnPlatform.Default>\n        <OnPlatform.iOS>\n            <SolidColorBrush Color="Yellow" />\n        </OnPlatform.Windows>\n    </OnPlatform>\n</ResourceDictionary>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"xml-combining-syntax",children:"XML Combining Syntax"}),"\n",(0,o.jsx)(n.p,{children:"To avoid branches duplication, it is possible to define multiple platforms in a single branch. Another useful example would be including platform-specific styles:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<Application.Styles>\n    \x3c!-- Always included --\x3e\n    <FluentTheme />\n\n    \x3c!-- Only one branch is executed in runtime --\x3e\n    <OnPlatform>\n        \x3c!-- if (Android || iOS) --\x3e\n        <On Options="Android, iOS">\n            <StyleInclude Source="/Styles/Mobile.axaml" />\n        </On>\n        \x3c!-- else --\x3e\n        <On Options="Default">\n            <StyleInclude Source="/Styles/Default.axaml" />\n        </On>\n    </OnPlatform>\n</Application.Styles>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"additional-details",children:"Additional details"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"OnPlatform"})," markup extension works in a similar way to how switch-case works in C# code. Compiler will generate branches for all possible values, but only one branch will be executed at runtime depending on the condition."]}),"\n",(0,o.jsxs)(n.p,{children:["It is also useful to remember that if an application is built with a specific ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/rid-catalog",children:"Runtime Identifier"})," and with ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options",children:"Trimming Enabled"}),", ",(0,o.jsx)(n.code,{children:"OnPlatform"})," extension will have its branches trimmed only to those that are possible. For example, if ",(0,o.jsx)(n.code,{children:"OnPlatform"})," had branches for Windows and macOS, but was built for Windows only, other branches will be removed, which also reduces application size."]}),"\n",(0,o.jsx)(n.h2,{id:"onformfactor-markup-extension",children:"OnFormFactor Markup Extension"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"OnFormFactor"})," markup extension functions similarly to the ",(0,o.jsx)(n.code,{children:"OnPlatform"})," and has the same general syntax. The main difference is that it allows defining values not per platform, but per device form factor, such as Desktop and Mobile:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<UserControl xmlns=\"https://github.com/avaloniaui\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\">\n    <TextBlock Text=\"{OnFormFactor 'Default value', Mobile='Im Mobile', Desktop='Im Desktop'}\"/>\n</UserControl>\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"OnFormFactor"})," doesn't have any compile-time trimming optimizations, as form factor cannot be known in compile time. None of these markup extensions are dynamic; once a value is set, it will not be changed."]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var i=t(96540);const o={},a=i.createContext(o);function l(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);